#!/bin/sh

# Define where your age public key for sops is stored
AGE_KEY_FILE=".sops/age/public.key"
if [ ! -f "$AGE_KEY_FILE" ]; then
  echo "Age key file not found: $AGE_KEY_FILE"
  exit 1
fi
PUBLIC_KEY=$(cat "$AGE_KEY_FILE")

# Function to compute SHA-256 hash of file content
compute_hash() {
  sha256sum "$1" | awk '{print $1}'
}

# Function to encrypt file with sops
encrypt_file() {
  local file=$1
  local ext=${file##*.}
  local enc_file="${file%.$ext}.enc.$ext"
  local sops_args="--encrypt --age $PUBLIC_KEY"

  # Add YAML-specific regex if needed
  if [ "$ext" = "yaml" ]; then
    sops_args="$sops_args --encrypted-regex '^(data|stringData)$'"
  fi

  # Encrypt and add hash comment
  if eval "sops $sops_args '$file'" > "$enc_file"; then
    local hash=$(compute_hash "$file")
    echo "# Hash: $hash" >> "$enc_file"
    echo "Encrypted and updated: $enc_file"
    git add "$enc_file"
    return 0
  else
    return 1
  fi
}

# Process both yaml and env files
for ext in yaml env auto.tfvars; do
  # Find all *secret.$ext files that aren't already encrypted
  for file in $(git diff --cached --name-only | grep ".*secret\.$ext$" | grep -v "\.enc\.$ext$"); do
    current_hash=$(compute_hash "$file")
    enc_file="${file%.$ext}.enc.$ext"

    if [ -f "$enc_file" ]; then
      previous_hash=$(tail -n 1 "$enc_file" | grep '# Hash:' | cut -d' ' -f3)
      if [ "$current_hash" != "$previous_hash" ]; then
        if ! encrypt_file "$file"; then
          echo "Failed to encrypt $file"
          continue
        fi
      else
        echo "No changes detected in $file. Skipping encryption."
      fi
    else
      if ! encrypt_file "$file"; then
        echo "Failed to encrypt $file"
        continue
      fi
    fi

    # Unstage the plaintext file
    git reset HEAD -- "$file"
  done
done

exit 0